---
title: "ChIP-seq data analysis"
author: "YOUR_NAME"
date: "`r format(Sys.time(), '%m/%d/%Y')`"
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    code_folding: show
---


# Annotation and Functional Analysis

## Learning Objectives

* Annotating peaks with gene and genomic feature information
* Obtaining biological context for identified binding sites using functional enrichment tools
* Using the seqqunce data for peaks to identify possible over-represented motifs

We have identified regions of the genome that are enriched in the number of aligned reads for each of our transcription factors of interest, Nanog and Pou5f1. These enriched regions represent the likely locations of where these proteins bind to the genome. After we obtain a list of peak coordinates, **it is important to study the biological implications of the protein DNA bindings**. Certain questions have always been asked: what are the **genomic annotations and the functions** of these peak regions?


![](./img/chip_workflow_june2017_step5.png)

## Peak Annotation

Because many cis-regulatory elements are close to TSSs of their targets, it is common to associate each peak to its nearest gene, either upstream or downstream. [ChIPseeker](http://bioconductor.org/packages/release/bioc/vignettes/ChIPseeker/inst/doc/ChIPseeker.html) is an R Bioconductor package for annotating peaks. Additionally, it has various visualization functions to assess peak coverage over chromosomes and profiles of peaks binding to TSS regions. 

load all required libraries:

```{r setup, include=FALSE}
# knitr::opts_chunk$set(echo = TRUE)

# Load libraries
library(BiocManager)
library(ChIPseeker)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(EnsDb.Hsapiens.v75)
library(clusterProfiler)
library(AnnotationDbi)
library(org.Hs.eg.db)


suppressPackageStartupMessages({
    library(ChIPpeakAnno)
    library(trackViewer)
    library(biomaRt)
    library(AnnotationHub)
    library(EnsDb.Hsapiens.v75)
    library(TxDb.Hsapiens.UCSC.hg19.knownGene)
    library(BSgenome.Hsapiens.UCSC.hg19)
    library(org.Hs.eg.db)
    library(UpSetR)
    library(seqinr)
    library(motifStack)
    library(WriteXLS)
    library(rtracklayer)
    library(rmarkdown)
    library(knitr)})

## Setup figure caption
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
i <- 0
generateFigureCaption <- function(cap) {
    i <<- i+1
    #return(paste0("Figure ", i, ". ", cap))
    return(cap)
}

```

### Loading data 

Peak annotation is generally performed on your high confidence peak calls (after looking at concordance betwee replicates). While we have a confident peak set for our data, this set is rather small and will not result in anything meaningful in our functional analyses. **We have generated a set of high confidence peak calls using the full dataset.** These were obtained post-IDR analysis, (i.e. concordant peaks between replicates) and are provided in BED format which is optimal input for the ChIPseeker package. 

> **NOTE:** the number of peaks in these BED files are are significantly higher than what we observed with the smaller dataset that we have been working with.

```{r, echo=T,eval=T,message=F,warning=F,error=F}

# Load data
samplefiles <- list.files("./data/idr-bed", pattern= ".bed", full.names=T)
# samplefiles <- list.files("data/idr-bed", pattern= ".bed", full.names=T)
samplefiles <- as.list(samplefiles)
names(samplefiles) <- c("Nanog", "Pou5f1")

```

Next, we need to **assign annotation databases** generated from UCSC to a variable:

```{r, echo=T,eval=T,message=F,warning=F,error=F}
	txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
```

> **NOTE:** *ChIPseeker supports annotating ChIP-seq data of a wide variety of species if they have transcript annotation TxDb object available.* To find out which genomes have the annotation available follow [this link](http://bioconductor.org/packages/3.5/data/annotation/) and scroll down to "TxDb". Also, if you are interested in creating your own TxDb object you will find [more information here](https://bioconductor.org/packages/devel/bioc/vignettes/GenomicFeatures/inst/doc/GenomicFeatures.pdf). 

### Annotation

Many annotation tools use nearest gene methods for assigning a peak to a gene in which the algorithm looks for the nearest TSS to the given genomic coordinates and annotates the peak with that gene. This can be misleading as **binding sites might be located between two start sites of different genes**.

The **`annotatePeak` function**, as part of the ChIPseeker package, uses the nearest gene method described above but also **provides parameters to specify a max distance from the TSS.** For annotating genomic regions, `annotatePeak` will not only give the gene information but also reports detail information when genomic region is Exon or Intron. For instance, âExon (uc002sbe.3/9736, exon 69 of 80)', means that the peak overlaps with the 69th exon of the 80 exons that transcript uc002sbe.3 possess and the corresponding Entrez gene ID is 9736. 


![](./img/annotate-genes.png)

Let's start by retrieving annotations for our Nanog and Pou5f1 peaks calls:

```{r, echo=T,eval=T,message=F,warning=F,error=F}
peakAnnoList <- lapply(samplefiles, annotatePeak, TxDb=txdb, 
                       tssRegion=c(-1000, 1000), verbose=FALSE)
```

If you take a look at what is stored in `peakAnnoList`, you will see that the peak annotations have been summarized for you based on genomic features:

```{}
> peakAnnoList
$Nanog
Annotated peaks generated by ChIPseeker
11023/11035  peaks were annotated
Genomic Annotation Summary:
             Feature  Frequency
9           Promoter 17.1731833
4             5' UTR  0.2358705
3             3' UTR  0.9706976
1           1st Exon  0.5443164
7         Other Exon  1.7781003
2         1st Intron  7.2121927
8       Other Intron 28.2318788
6 Downstream (<=3kb)  0.9434818
5  Distal Intergenic 42.9102785

$Pou5f1
Annotated peaks generated by ChIPseeker
3242/3251  peaks were annotated
Genomic Annotation Summary:
             Feature  Frequency
9           Promoter  3.7939543
4             5' UTR  0.1542258
3             3' UTR  1.0795805
1           1st Exon  1.3263418
7         Other Exon  1.6347933
2         1st Intron  7.4336829
8       Other Intron 30.9685379
6 Downstream (<=3kb)  0.9561999
5  Distal Intergenic 52.6526835
```

ChIPseeker provides several functions to visualize the annotations using various plots. We will demonstrate a few of these using the Nanog sample. We will also show you how some of the functions can support comparing annotation information across samples.

> **NOTE**: ChIPseeker also has functionality to **generate figures for visualization** (similar to what we did in `deepTools`). If you are interested in testing out those functions on this data, please see the [materials linked here](https://hbctraining.github.io/Intro-to-ChIPseq/lessons/chipseeker_visualization.html).


### Barchart of genomic feature representation

```{r, echo=T,eval=T,message=F,warning=F,error=F}
plotAnnoBar(peakAnnoList)

```

### Distribution of TF-binding loci relative to TSS

```{r, echo=T,eval=T,message=F,warning=F,error=F}
plotDistToTSS(peakAnnoList, title="Distribution of transcription factor-binding loci \n relative to TSS")
```

Finally, it would be nice to have the **annotations for each peak call written to file**, as it can be useful to browse the data and subset calls of interest. The annotation information is stored in the `peakAnnoList` object. To retrieve it we use the following syntax:

```{r, echo=T,eval=T,message=F,warning=F,error=F}
	nanog_annot <- data.frame(peakAnnoList[["Nanog"]]@anno)
```

Take a look at this data frame. You should see columns corresponding to your input BED file and addditional columns containing nearest gene(s), the distance from peak to the TSS of its nearest gene, genomic feature annotation of the peak and other information. Since some annotations may overlap, ChIPseeker has adopted the following priority in how it lists information:

* Promoter
* 5' UTR
* 3' UTR
* Exon
* Intron
* Downstream (defined as the downstream of gene end)
* Intergenic

One thing you will notice is that the gene identifiers that are listed are EntrezIDs. It would be easier to browse through the results if we had gene symbols. We will obtain this information using `AnnotationDbi`, an R package that provides an interface for connecting and querying various annotation databases using SQLite data storage. The AnnotationDbi packages can query the OrgDb, TxDb, EnsDb, Go.db, and BioMart annotations. There is [helpful documentation](https://bioconductor.org/packages/release/bioc/vignettes/AnnotationDbi/inst/doc/IntroToAnnotationPackages.pdf) available to reference when extracting data from any of these databases.

Although we have been using the TxDb database with ChIPseeker, there is limited options as to what other identifiers can be retrieved.

```{}

keytypes(TxDb.Hsapiens.UCSC.hg19.knownGene)
[1] "CDSID"    "CDSNAME"  "EXONID"   "EXONNAME" "GENEID"   "TXID"     "TXNAME"  
```

Since we want to map our EntrezIDs to gene symbols, we will need to use another database. The `EnsDb.Hsapiens.v75` database corresponds to hg19, and so is an appropriate option.

```{r, echo=T,eval=T,message=F,warning=F,error=F}
# Get the entrez IDs
entrez <- nanog_annot$geneId

# Return the gene symbol for the set of Entrez IDs
annotations_edb <- AnnotationDbi::select(EnsDb.Hsapiens.v75,
                                         keys = entrez,
                                         columns = c("GENENAME"),
                                         keytype = "ENTREZID")

# Change IDs to character type to merge
annotations_edb$ENTREZID <- as.character(annotations_edb$ENTREZID)

# Write to file
# nanog_annot %>% 
#   left_join(annotations_edb, by=c("geneId"="ENTREZID")) %>% 
#   write.table(file="results/Nanog_peak_annotation.txt", sep="\t", quote=F, row.names=F)
```


## Functional enrichment: R-based tools

Once we have obtained gene annotations for our peak calls, we can perform functional enrichment analysis to **identify predominant biological themes among these genes** by incorporating knowledge from biological ontologies such as Gene Ontology, KEGG and Reactome. The gene lists we have obtained through annotation can be interepreted using freely available web- and R-based tools. In this workshop we will focus on the latter, but we will also mention the former and provide resources if you are interested in web-based tools.

### Over-representation analysis

There are a plethora of functional enrichment tools that perform some type of over-representation analysis by querying databases containing information about gene function and interactions. Querying these databases for gene function requires the use of a consistent vocabulary to describe gene function. One of the **most widely-used vocabularies is the Gene Ontology (GO)**. This vocabulary was established by the Gene Ontology project, and the words in the vocabulary are referred to as GO terms.

We will be using [`clusterProfiler`](http://bioconductor.org/packages/release/bioc/html/clusterProfiler.html) to perform over-representation analysis on GO terms associated with our list of significant genes. The tool takes as input a significant gene list and a background gene list and performs statistical enrichment analysis using hypergeometric testing. The basic arguments allow the user to select the appropriate organism and GO ontology (BP, CC, MF) to test.

Let's start with our gene list from **Nanog annotations** and use them as input for a **GO enrichment analysis of biological process terms**.

```{r, echo=T,eval=T,message=F,warning=F,error=F}
# Run GO enrichment analysis 
ego <- enrichGO(gene = entrez, 
                    keyType = "ENTREZID", 
                    OrgDb = org.Hs.eg.db, 
                    ont = "BP", 
                    pAdjustMethod = "BH", 
                    qvalueCutoff = 0.05, 
                    readable = TRUE)

```

The `ego` object we created contains the results of the over-representation analysis. We can extract it into a data frame and **write the results to file**:

```{r, echo=T,eval=T,message=F,warning=F,error=F}
# Output results from GO analysis to a table
cluster_summary <- data.frame(ego)
write.csv(cluster_summary, "results/clusterProfiler_Nanog.csv")
```

We can also use the `ego` object to **visualize the results** using the `dotplot()` function. The **dotplot** shows the number of genes associated with the first 50 terms (size) and the p-adjusted values for these terms (color). This plot displays the top 50 genes by gene ratio (# genes related to GO term / total number of sig genes), not p-adjusted value.

```{r, fig.width=10,fig.height=12, echo=T,eval=T,message=F,warning=F,error=F}
# Dotplot visualization
dotplot(ego, showCategory=50)
```


We find many terms related to **development and differentiation** and amongst those we see the term 'stem cell population maintenance'. This makes sense since functionally, Nanog blocks differentiation. Thus, negative regulation of Nanog is required to promote differentiation during embryonic development. Recently, Nanog has been shown to be involved in neural stem cell differentiation which might explain the abundance of brain-related terms we observe.


Another popular resource for pathway level annotations is the [KEGG database](https://www.genome.jp/kegg/catalog/org_list.html). There is a function in `clusterProfiler` that allows us to perform **KEGG pathway enrichment** and visualize the results using the the dotplot. Again, we see a relevant pathway 'Signaling pathways regulating pluripotency of stem cells' is enriched.

```{r, echo=T,eval=T,message=F,warning=F,error=F}
ekegg <- enrichKEGG(gene = entrez,
                 organism = 'hsa',
                 pvalueCutoff = 0.05)

dotplot(ekegg)
```

### Comparing enrichment across samples

Our dataset consists of two different transcription factor peak calls, so it would be useful to be able to compare functional enrichment results side-by-side in the same plot. We can do this using the `compareCluster` function. We see similar terms showing up, and in particular the stem cell term is more significant (with a higher gene ratio) in the Pou5f1 target gene list.

```{r, echo=T,eval=T,message=F,warning=F,error=F}
# Create a list with genes from each sample
genes = lapply(peakAnnoList, function(i) as.data.frame(i)$geneId)

# Run KEGG analysis
compKEGG <- compareCluster(geneCluster = genes, 
                         fun = "enrichKEGG",
                         organism = "human",
                         pvalueCutoff  = 0.05, 
                         pAdjustMethod = "BH")
dotplot(compKEGG, showCategory = 20, title = "KEGG Pathway Enrichment Analysis")
```


## Functional enrichment: Web-based tools

There are also web-based tool for enrichment analysis on genomic regions, and **a popular one is [GREAT](http://great.stanford.edu/public/html/)** (Genomic Regions Enrichment of Annotations Tool). GREAT is used to analyze the functional significance of cis-regulatory regions identified by localized measurements of DNA binding events across an entire genome[1](http://bejerano.stanford.edu/papers/GREAT.pdf). It **incorporates annotations from 20 different ontologies** and is an easy to use tool which generates annotation and downstream functional enrichement results for genomic coordinate files. The utility of GREAT is not limited to ChIP-seq, as it could also be applied to open chromatin, localized epigenomic markers and similar functional data sets, as well as comparative genomics sets.

In the interest of time we will not go into the details of using GREAT, however we have [materials linked here](https://hbctraining.github.io/Intro-to-ChIPseq/lessons/web_based_functional_analysis.html) if you are interested in testing it out with this dataset. There also [demo datasets](http://great.stanford.edu/public/html/demo.php) on the GREAT website that you can use to test out the functionality of the tool.


## Motif discovery

![MEME_suite](./img/meme_suite.png)

To identify over-represented motifs, we will use DREME from the MEME suite of sequence analysis tools. [DREME](http://meme-suite.org/tools/dreme) is a motif discovery algorithm designed to find short, core DNA-binding motifs of eukaryotic transcription factors and is optimized to handle large ChIP-seq data sets.

DREME is tailored to eukaryotic data by focusing on short motifs (4 to 8 nucleotides) encompassing the DNA-binding region of most eukaryotic monomeric transcription factors. Therefore it may miss wider motifs due to binding by large transcription factor complexes.


### DREME

Visit the [DREME website](http://meme-suite.org/tools/dreme) and perform the following steps:

1. You will **need a FASTA file which contains the sequences of all of the genomic regions of interest**. This can be generated from your IDR BED files by following the instructions in our [materials linked here](https://hbctraining.github.io/Intro-to-ChIPseq/lessons/motif_analysis_prep.html). In the interest of time, we have generated this file for you (using the full dataset) and it can be [downloaded via this link](https://github.com/hbctraining/Intro-to-ChIPseq/raw/master/Nanog-idr-merged-dreme.fasta).
2. Select the downloaded `Nanog-idr-merged-dreme.fasta` as input to DREME
3. Enter your email address so that DREME can email you once the analysis is complete
4. Enter a job description so you will recognize which job has been emailed to you and then start the search

You will be shown a status page describing the inputs and the selected parameters, as well as links to the results at the top of the screen.

![results_page](./img/dreme_processing.png)

This may take some time depending on the server load and the size of the file. While you wait, take a look at the [expected results](https://github.com/hbctraining/Intro-to-ChIPseq/raw/master/chipseq_DREME_report.pdf).

![dreme_output](./img/dreme_output.png)

DREME's HTML output provides a list of Discovered Motifs displayed as sequence logos (in the forward and reverse complement (RC) orientations), along with an E-value for the significance of the result. 

Motifs are significantly enriched if the fraction of sequences in the input dataset matching the motif is significantly different from the fraction of sequences in the background dataset using Fisher's Exact Test. Typically, background dataset is either similar data from a different ChIP-seq experiment or shuffled versions of the input dataset [[1](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3106199/)].

Clicking on `More` displays the number of times the motif was identified in the Nanog dataset (positives) versus the background dataset (negatives). The `Details` section displays the number of sequences matching the motif, while `Enriched Matching Words` displays the number of times the motif was identified in the sequences (more than one word possible per sequence).

### Tomtom

To determine if the identified motifs resemble the binding motifs of known transcription factors, we can submit the motifs to Tomtom, which searches a database of known motifs to find potential matches and provides a statistical measure of motif-motif similarity. We can run the analysis individually for each motif prediction by performing the following steps:

1. Click on the `Submit / Download` button for motif `ATGYWAAT` in the DREME output
2. A dialog box will appear asking you to Select what you want to do or Select a program. Select `Tomtom` and click `Submit`. This takes you to the input page. 
3. Tomtom allows you to select the database you wish to search against. Keep the default parameters selected, but keep in mind that there are other options when performing your own analyses.
4. Enter your email address and job description and start the search.

You will be shown a status page describing the inputs and the selected parameters, as well as a link to the results at the top of the screen. Clicking the link displays an output page that is continually updated until the analysis has completed. Like DREME, Tomtom will also email you the results.

The HTML output for Tomtom shows a list of possible motif matches for the DREME motif prediction generated from your Nanog regions. Clicking on the match name shows you an alignment of the predicted motif versus the match. [Click here to visualize a PDF of the report](https://github.com/hbctraining/Intro-to-ChIPseq/raw/master/chipseq_TOMTOM_report.pdf)

![tomtom_output](./img/tomtom_output.png)

The short genomic regions identified by ChIP-seq are generally very highly enriched with binding sites of the ChIP-ed transcription factor, but Nanog is not in the databases of known motifs. The regions identified also tend to be enriched for the binding sites of other transcription factors that bind *cooperatively or competitively* with the ChIP-ed transcription factor.

If we compare our results with what is known about our transcription factor, Nanog, we find that Sox2 and Pou5f1 (Oct4) co-regulate many of the same genes as Nanog. 


![nanog](./img/nanog_binding.png)[https://www.qiagen.com/us/shop/genes-and-pathways/pathway-details/?pwid=309](https://www.qiagen.com/us/shop/genes-and-pathways/pathway-details/?pwid=309)


### MEME-ChIP

MEME-ChIP is a tool that is part of the MEME Suite that is specifically designed for ChIP-seq analyses. MEME-ChIP performs DREME and Tomtom analysis in addition to using tools to assess which motifs are most centrally enriched (motifs should be centered in the peaks) and to combine related motifs into similarity clusters. It is able to identify longer motifs < 30bp, but takes much longer to run. The report generated by MEME-ChIP is available [here](https://github.com/hbctraining/Intro-to-ChIPseq/raw/master/chipseq_MEME%20ChIP_report.pdf).

> ![](./img/meme_chip_output.png)

## Example1: annotate ChIP-seq peaks with ChIPpeakAnno {-#my-section}

Four steps:

1. Read in peak data with `toGRanges`

2. Generate annotation data with `toGRanges`

3. Annotate peaks with `annotatePeakInBatch`

4. Add additional info with `addGeneIDs`

### Step 1: read in peak data {-#my-section}

We first need to convert peak files from bed/broadPeak/narrowPeak etc. format to `GRanges` object with `toGRanges` function.

For the lesson, we will use the example data stored in ChIPpeakAnno package.

```{r "readPeaks"}
## locate example data:
path <- system.file("extdata", "Tead4.broadPeak", package="ChIPpeakAnno")
## read in peak file:
peaks <- toGRanges(path, format="broadPeak")
## inspect the top 2 lines of the peak file in GRanges format:
head(peaks, n=2)
```

### Step 2: prepare annotation data {-#my-section}

Depending on your research goals, you can choose to use either ENSEMBL or UCSC annotations.

The more complex ENSEMBL annotation is preferred when the goal is to discover and explain unknown biological mechanisms.

The less complex UCSC annotation can be used to generate more robust and reproducible results.

```{r "TxDbAnnoData"}
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
annoDataTxDb <- toGRanges(TxDb.Hsapiens.UCSC.hg19.knownGene)
## inspect the first two lines of the annotation file:
head(annoDataTxDb, n=2)
```

### Step 3: annotate peaks {-#my-section}

```{r "annotateTxDb"}
## annotate by the nearest TSS based on UCSC hg19 annotations
annoTxDb <- annotatePeakInBatch(peaks, AnnotationData=annoDataTxDb)
## inspect the first two lines of the annotation:
head(annoTxDb, n=2)
```

### Step 4: add additional annotation {-#my-section}

```{r "addIDs"}
library(org.Hs.eg.db)
## add in gene symbol
annoTxDb <- addGeneIDs(annoTxDb, orgAnn="org.Hs.eg.db",
                        feature_id_type="entrez_id",
                        IDs2Add=c("symbol"))
## inspect the first two lines:
head(annoTxDb, n=2)
```

Short summary:

Be careful that peak annotation results may differ depending on the source of your annotation file.

## Example 2: find overlaps for replicates {-#my-section}

The output **overlappingPeaks** object of the module `findOverlapsOfPeaks` consists of the followings:

1. venn_cnt

2. peaklist: a list of overlapping or unique peaks

3. overlappingPeaks: a list of data frame that consists of the annotations of all overlapping peaks

Below, we would like to find the overlaps between two peak files: one from BED, the other from GFF.

```{r "findOverlapsOfPeaks", fig.cap=generateFigureCaption("Venn diagram of overlaps for replicates"), fig.width=3, fig.height=3}
library(ChIPpeakAnno)
## convert BED file to GRanges:
bed <- system.file("extdata", "MACS_output.bed", package="ChIPpeakAnno")
gr1 <- toGRanges(bed, format="BED", header=FALSE)
## convert GFF file to GRanges:
gff <- system.file("extdata", "GFF_peaks.gff", package="ChIPpeakAnno")
gr2 <- toGRanges(gff, format="GFF", header=FALSE, skip=3)
## must keep the class of gr2$score the same as gr1$score, i.e., numeric:
gr2$score <- as.numeric(gr2$score)
## find overlaps:
ol <- findOverlapsOfPeaks(gr1, gr2, connectedPeaks = "keepAll")
## add metadata (mean of score) to the overlapping peaks
ol <- addMetadata(ol, colNames="score", FUN=mean)
## inspect the first two lines of overlapping peaks:
head(ol$peaklist[["gr1///gr2"]], n=2)
## make a Venn diagram:
makeVennDiagram(ol, fill=c("#009E73", "#F0E442"),
                     col=c("#D55E00", "#0072B2"),
                 cat.col=c("#D55E00", "#0072B2"))
```

## Example 3: visualize peak site distribution {-#my-section}

The `assignChromosomeRegion` function summarizes the distribution of peaks over various features (exon, intron, enhancer, promoter and UTR).

Results can be displayed in either peak-centric or nucleotide-centric view.

Note that a single peak might span multiple type of features.

#### Binding site relative to features {-#my-section}

```{r "assignChromosomeRegion", fig.cap=generateFigureCaption("Peak distribution over different genomic features."), fig.width=6, fig.height=3}
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
## get overlapping peaks:
overlaps <- ol$peaklist[["gr1///gr2"]]
## find peak site distribution:
aCR <- assignChromosomeRegion(overlaps, nucleotideLevel=FALSE,
                              precedence=c("Promoters",
                                           "immediateDownstream",
                                           "fiveUTRs",
                                           "threeUTRs",
                                           "Exons",
                                           "Introns"),
                              TxDb=TxDb.Hsapiens.UCSC.hg19.knownGene)
## use barplot to visualize:
barplot(aCR$percentage, las=3)
```

#### Peak distance distribution to nearest feature {-#my-section}

```{r "binOverFeature", fig.cap=generateFigureCaption("Distribution of peaks around TSS."), fig.width=6, fig.height=3}
binOverFeature(overlaps, annotationData=annoDataTxDb,
               radius=5000, nbins=20, FUN=length, errFun=0,
               ylab="count",
               main="Distribution of aggregated peak numbers around TSS")
```

#### Annotate peaks to promoter regions (-500bp ~ +2000bp) {-#my-section}

```{r}
library(org.Hs.eg.db)
## annotate to promoter regions:
overlaps.anno <- annotatePeakInBatch(overlaps,
                                     AnnotationData=annoDataTxDb,
                                     output="nearestBiDirectionalPromoters",
                                     bindingRegion=c(-2000, 500))
## add in gene symbol:
overlaps.anno <- addGeneIDs(overlaps.anno,
                            "org.Hs.eg.db",
                            feature_id_type="entrez_id",
                            IDs2Add = "symbol")
## visualized the first two lines:
head(overlaps.anno, n=2)
```

## Example 4: find peaks with bi-directional promoters {-#my-section}

Bi-directional promoters refer to genomic regions that are located between TSS of two adjacent genes that are transcribed on opposite directions. Bi-directional promoters often regulate both genes.

```{r "peaksNearBDP16"}
## find bi-directional promoters:
bdp <- peaksNearBDP(overlaps, annoDataTxDb, maxgap=5000)
## some statistics:
c(bdp$percentPeaksWithBDP,
  bdp$n.peaks,
  bdp$n.peaksWithBDP)
## show first two lines:
head(bdp$peaksWithBDP, n=2)
```

## Example 5: output a summary of peak consensus {-#my-section}

Many methods are available:

1. Use `getAllPeakSequence` module to output fastq file and sesarch the motif by other tools like MEME and HOMER.

2. Compare pre-defined patterns against target consensus patterns with `summarizePatternInPeaks` module.

3. Calculate the z-scores for all combinations of oligonucleotide at a given length with the `oligoSummary` module.

Below demonstrates method 3.

```{r "consensus", fig.cap=generateFigureCaption("Histogram of Z-score of 6-mer"), fig.height=3, fig.width=6}
library(seqinr)
library(BSgenome.Hsapiens.UCSC.hg19)
## obtain peak sequences:
seq <- getAllPeakSequence(overlaps,
                          upstream=20, downstream=20,
                          genome=Hsapiens)
## output the fasta file for the 3nd program:
#write2FASTA(seq, "test.fa")
## summarize short oligos:
os <- oligoSummary(seq, oligoLength=6, MarkovOrder=3, quickMotif=TRUE)
## plot z-scores:
zscore <- sort(os$zscore)
h <- hist(zscore, breaks=100, main="Histogram of Z-score")
text(zscore[length(zscore)], max(h$counts)/10,
     labels=names(zscore[length(zscore)]), srt=90)
```

Generate motif using simulated data.

```{r "motif", fig.cap=generateFigureCaption("Motif of simulation data"), fig.width=6, fig.height=3}
library(motifStack)
## generate the motifs:
pfms <- mapply(function(.ele, id)
               new("pfm", mat=.ele, name=paste("SAMPLE motif", id)),
               os$motifs, 1:length(os$motifs))
motifStack(pfms)
```

## Example 6: obtain enriched GO and pathways {-#my-section}

Please note that by default, _feature_id|_type_ is set to "ensembl\_gene\_id", is you are using **TxDb** for your annotation, please set to "entrez\_id".

```{r enrichment}
library(reactome.db)
## obtain enriched GO term:
over <- getEnrichedGO(overlaps.anno, orgAnn="org.Hs.eg.db",
                      feature_id_type="entrez_id",
                      maxP=.05, minGOterm=10,
                      multiAdjMethod="BH", condense=TRUE)
## show first two lines:
head(over[["mf"]][, -c(3, 10)], n=2)
## obtain enriched pathways:
pathway <- getEnrichedPATH(overlaps.anno, "org.Hs.eg.db", "reactome.db",
                        feature_id_type="entrez_id", maxP=.05)
## show the first two lines:
head(pathway, n=2)
```

## Example 7: determine if there is significant peak overlap among multiple sets {-#my-section}

Given multiple peak lists, to see if the binding sites are correlated and what is the common binding pattern. Two methods: hypergeometric test and permutation test.

#### Method 1: hypergeometric test {-#my-section}

This method requires the number of all potential binding sites to be known. You need to set the _totalTest_ (total potential peak number) in the `makeVennDiagram` module. The value should be larger than the max number of peaks in the peak list.

In the example below, we assume a 3% coding region plus promoters. Since the sample data is only a subset of chr2, we estimate that the total binding sites is 1/24 of possible binding region in the genome.

```{r "vennDiagram", fig.cap=generateFigureCaption("Venn diagram of overlaps."), fig.width=4, fig.height=4}
## read in data: TAF, Tead4 and YY1
path <- system.file("extdata", package="ChIPpeakAnno")
files <- dir(path, "broadPeak")
data <- sapply(file.path(path, files), toGRanges, format="broadPeak")
(names(data) <- gsub(".broadPeak", "", files))
## find overlapped peaks:
ol <- findOverlapsOfPeaks(data, connectedPeaks="keepAll")
## avergage of peak width:
averagePeakWidth <- mean(width(unlist(GRangesList(ol$peaklist))))
## estimate of total binding site;
tot <- ceiling(3.3e+9 * .03 / averagePeakWidth / 24)
## make Venn diagram:
makeVennDiagram(ol, totalTest=tot, connectedPeaks="keepAll",
                fill=c("#CC79A7", "#56B4E9", "#F0E442"),
                col=c("#D55E00", "#0072B2", "#E69F00"),
                cat.col=c("#D55E00", "#0072B2", "#E69F00"))
```

Keep first list consistent.

```{r "vennDiagramForFirstConsistent", fig.cap=generateFigureCaption("Venn diagram of overlaps for first TF."), fig.width=4, fig.height=4}
## set connectedPeaks to keepFirstListConsistent will show consistent total number of peaks for the first peak list.
makeVennDiagram(ol, totalTest=tot, connectedPeaks="keepFirstListConsistent",
                fill=c("#CC79A7", "#56B4E9", "#F0E442"),
                col=c("#D55E00", "#0072B2", "#E69F00"),
                cat.col=c("#D55E00", "#0072B2", "#E69F00"))
```

#### Method 2: Permutation test {-#my-section}

With `peakPermTest`, users don't need to estimate total potential binding sites.

Before permutation test, random peaks need to be generated using the distribution discovered from the input peak for a given feature type. Alternatively, a peak pool can be prepared with `preparePool` module. Below is an exmple using the transcription factor binding site clusters (V3) (see ?`wgEncodeTfbsV3`)
downloaded from [ENCODE](http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeRegTfbsClustered/wgEncodeRegTfbsClusteredV3.bed.gz)
with the HOT spots (?`HOT.spots`) removed.

HOT spots are regions with probability to be bound by many TFs. We suggest to remove them before the test. Users can also choose to remove blacklist [ENCODE blacklist](https://sites.google.com/site/anshulkundaje/projects/blacklists) regions. Note that some blacklists need to be converted to the correct genome assembly with liftover utility.

```{r "peakPermTest", fig.cap=generateFigureCaption("permutation test for YY1 and TEAD4"), fig.width=6, fig.height=6}
## read in data:
data(HOT.spots)
data(wgEncodeTfbsV3)
hotGR <- reduce(unlist(HOT.spots))
## remove HOT spots:
removeOl <- function(.ele){
    ol <- findOverlaps(.ele, hotGR)
    if(length(ol)>0) .ele <- .ele[-unique(queryHits(ol))]
    .ele
}
TAF <- removeOl(data[["TAF"]])
TEAD4 <- removeOl(data[["Tead4"]])
YY1 <- removeOl(data[["YY1"]])
## subset to save demo time:
set.seed(1)
wgEncodeTfbsV3.subset <- wgEncodeTfbsV3[sample.int(length(wgEncodeTfbsV3), 2000)]
## YY1 vs TEAD4:
pool <- new("permPool", grs=GRangesList(wgEncodeTfbsV3.subset), N=length(YY1))
pt1 <- peakPermTest(YY1, TEAD4, pool=pool, seed=1, force.parallel=FALSE)
plot(pt1)
```

```{r peakPermTest2, fig.cap=generateFigureCaption("permutation test for YY1 and TAF"), fig.width=6, fig.height=6}
## YY1 vs TAF:
pt2 <- peakPermTest(YY1, TAF, pool=pool, seed=1, force.parallel=FALSE)
plot(pt2)
```

## Example 8: metagene analysis for a given feature/peak range {-#my-section}

You can easily visualize and compare the binding patterns of raw signals of
multiple ChIP-seq experiments using function `featureAlignedHeatmap` and `featureAlignedDistribution`.

Heatmap of aligned features.

```{r "heatmap", fig.cap=generateFigureCaption("Heatmap of aligned features sorted by signal of TAF"), fig.width=4, fig.height=6}

library(rtracklayer)
## recenter features:
features <- ol$peaklist[[length(ol$peaklist)]]
feature.recentered <- reCenterPeaks(features, width=4000)
## read in data:
path <- system.file("extdata", package="ChIPpeakAnno")
files <- dir(path, "bigWig")
if(.Platform$OS.type != "windows"){
    cvglists <- sapply(file.path(path, files), import,
                       format="BigWig",
                       which=feature.recentered,
                       as="RleList")
} else {
    load(file.path(path, "cvglist.rds"))
}
## extract signal:
names(cvglists) <- gsub(".bigWig", "", files)
feature.center <- reCenterPeaks(features, width=1)
sig <- featureAlignedSignal(cvglists, feature.center,
                            upstream=2000, downstream=2000)
## output heatmap
keep <- rowSums(sig[[2]]) > 0
sig <- sapply(sig, function(.ele) .ele[keep, ], simplify = FALSE)
feature.center <- feature.center[keep]
heatmap <- featureAlignedHeatmap(sig, feature.center,
                                 upstream=2000, downstream=2000,
                                 upper.extreme=c(3,.5,4))
```

Distriution of aligned features.

```{r "distribution",fig.cap=generateFigureCaption("Distribution of aligned features"), fig.width=5, fig.height=5}
featureAlignedDistribution(sig, feature.center,
                           upstream=2000, downstream=2000,
                           type="l")
```

## Example 9: creating lollipop plot with trackViewer {-#my-section}

It is routine to show the distribution of mutation or genetic variations by lollipop-style (or needle-style) plot in a genome browser, along with a variety of genomic annotations, such as gene or exon level models, CpG island, and so on.

For SNP status or methlyation data, lollipop plot is often used. Many tools can provide lollipop plot such as cBioPortal Tools::MutationMapper[@gao2013integrative], EMBL-EBI::Pfam[@finn2006pfam], and BioJS::muts-needle-plot[@michael_p_schroeder_2015_14561], BiQ Analyzer[@bock2005biq], and Methylation plotter[@mallona2014methylation]. The cBioPortal Tools::MutationMapper is a well-known and easy to use online genome browser that can generate high quality figures with mutations by inputing tab-delimited mutation data. In R/Bioconductor, with the Rgraphics system, there are many flexible ways to display methylation data such as _MethVisual_[@zackay2010methvisual], _REDseq_[@zhu4redseq], and _GenVisR_[@skidmore2016genvisr].

Below is a summary of current tools that are available.

```{r echo=FALSE, warning=FALSE}
library(pander)
software <-
  c(
    "MutationMapper[@gao2013integrative]",
    "Pfam[@finn2006pfam]",
    "muts-needle-plot[@michael_p_schroeder_2015_14561]",
    "BiQ Analyzer[@bock2005biq]",
    "Methylation plotter[@mallona2014methylation]",
    "_MethVisual_[@zackay2010methvisual]",
    "_REDseq_[@zhu4redseq]",
    "_GenVisR_[@skidmore2016genvisr]"
  )
inputs <-
  c(
    "tab-delimited text",
    "JSON",
    "JSON",
    "BiQ methylation file",
    "tab-delimited text",
    "R list",
    "R list",
    "R dataframe"
  )
online <- c("Yes", "Yes", "No", "Yes", "Yes", "No", "No", "No")
description <-
  c(
    "interprets mutations with different heights along protein annotations in automatic color theme",
    "could combine different line and head colors with different drawing styles",
    "plots data point with different colors, heights, and size along annotations, and highlighted selcted coordinates",
    "interprets methylation status in black & white",
    "stacked multiple methylation status for multiple samples",
    "visualize the methylation status of CpGs according to their genomic position",
    "plot frequencies of methylations and SNPs along a chromosome",
    "plot most accurate graphic representation of the ensembl annotation version based on biomart service"
  )
df <-
  data.frame(
    software = software,
    inputs = inputs,
    online = online,
    description = description
  )
panderOptions('table.alignment.default', function(df)
  ifelse(sapply(df, is.numeric), 'right', 'left'))
panderOptions('table.split.table', Inf)
panderOptions('keep.trailing.zeros', TRUE)
pander(df)
```

Though the tools above meet the basic even advanced visualization requirement, they do have limitations. For example, it will be hard to display the data if there are multiple mutations in the same posistion. Moreover, generating high quality pictures in bunch for publication is also a pain.

To fill this gap, we developed _trackViewer_, a R/Bioconductor package serving as an enhanced light-weight genome viewer for visualizing various types of high-throughput sequencing data, side by side or stacked with multiple annotation tracks.

Besides the regular read coverage tracks supported by existing genome browsers/viewers,  _trackViewer_ can also generate lollipop plot to depict the methylation and SNP/mutation status, together with coverage data and annotation tracks to facilitate integrated analysis of multi-omics data. In addition, figures generated by _trackViewer_ are interactive, i.e., the feel-and-look such as the layout, the color scheme and the order of tracks can be easily customized by the users. Furthermore, _trackViewer_ can be easily integrated into standard analysis pipeline for various high-throughput sequencing dataset such as ChIP-seq, RNA-seq, methylation-seq or DNA-seq. The images produced by _trackViewer_ are highly customizable including labels, symbols, colors and size. Here, we illustrate its utilities and capabilities in deriving biological insights from multi-omics dataset from GEO/ENCODE.

There are 3 steps for generating lollipop plot:

1. Prepare the methylation/variant/mutation data.

2. Prepare the gene/protein model.

3. Plot lollipop plot.

#### Step 1: repare the methylation/variant/mutation data. {-#my-section}

```{r "quickStartStep1"}
library(trackViewer)
set.seed(123)
# Here we use SNP sample data
SNP <- c(10, 100, 105, 108, 400, 410, 420, 600, 700, 805, 840, 1400, 1402)
# use GenomicRanges::GRanges function to create a GRanges object.
# for real data, users can import vcf data via VariantAnnotation::readVcf function.
sample.gr <- GRanges("chr1", IRanges(SNP, width=1,
                     ## the name of GRanges object will be used as label
                     names=paste0("snp", SNP)),
                     ## score value will be used to for the height of lollipop
                     score = sample.int(5, length(SNP), replace = TRUE),
                     ## set the color for lollipop node.
                     color = sample.int(6, length(SNP), replace = TRUE),
                     ## set the lollipop stem color
                     border = sample(c("black", "gray80", "gray30"),
                     length(SNP), replace=TRUE))
```

#### Step 2: prepare the gene/protein model. {-#my-section}

```{r "quickStartStep2"}
features.gr <- GRanges("chr1", IRanges(c(1, 501, 1001),
                                       width=c(120, 400, 405),
                                       names=paste0("exon", 1:3)),
                       								 fill = c("#FF8833", "#51C6E6", "#DFA32D"), ## color for exon
                       								 height = c(0.02, 0.05, 0.08) ## height for exon
                    	)
```

#### Step 3: plot lollipop plot {-#my-section}

```{r "quickStartStep3", fig.width=6, fig.height=3.5}
lolliplot(sample.gr, features.gr)
```

## Example 10: plot from VCF file with trackViewer {-#my-section}
VCF is a text file format that contains metadata and mutation information about
genomic positions, original genotypes and optional genotypes.

The _trackViewer_ package can show single nucleotide polymorphisms (SNPs) from VCF file in lollipop plot. Figure \@ref(fig:plotVCFdata) shows an example lollipop plot of real SNPs. Sample SNPs are a subset of 1000 variants and 50 samples from chromosome 22 taken from 1000 Genomes in VCF in the _VariantAnnotation_ package. Different colors depict the new SNP events in the circles. The number of circles indicates the number of SNP events.

```{r plotVCFdata, fig.width=12, fig.height=5.5, dpi=72, fig.cap="lollipop plot for VCF data"}
library(VariantAnnotation) ## load package for reading vcf file
library(TxDb.Hsapiens.UCSC.hg19.knownGene) ## load package for gene model
library(org.Hs.eg.db) ## load package for gene name
library(rtracklayer)
fl <- system.file("extdata", "chr22.vcf.gz", package="VariantAnnotation")
## set the track range
gr <- GRanges("22", IRanges(50968014, 50970514, names="TYMP"))
## read in vcf file
tab <- TabixFile(fl)
vcf <- readVcf(fl, "hg19", param=gr)
## get GRanges from VCF object
mutation.frequency <- rowRanges(vcf)
## keep the metadata
mcols(mutation.frequency) <-
    cbind(mcols(mutation.frequency),
          VariantAnnotation::info(vcf))
## set colors
mutation.frequency$border <- "gray30"
mutation.frequency$color <-
    ifelse(grepl("^rs", names(mutation.frequency)),
           "lightcyan", "lavender")
## plot Global Allele Frequency based on AC/AN
mutation.frequency$score <- round(mutation.frequency$AF*100)
## change the SNPs label rotation angle
mutation.frequency$label.parameter.rot <- 45
## keep sequence level style same
seqlevelsStyle(gr) <- seqlevelsStyle(mutation.frequency) <- "UCSC"
seqlevels(mutation.frequency) <- "chr22"
## extract transcripts in the range
trs <- geneModelFromTxdb(TxDb.Hsapiens.UCSC.hg19.knownGene,
                         org.Hs.eg.db, gr=gr)
## subset the features to show the interested transcripts only
features <- c(range(trs[[1]]$dat), range(trs[[5]]$dat))
## define the feature labels
names(features) <- c(trs[[1]]$name, trs[[5]]$name)
## define the feature colors
features$fill <- c("lightblue", "mistyrose")
## define the feature heights
features$height <- c(.02, .04)
## set the legends
legends <- list(labels=c("known", "unkown"),
                fill=c("lightcyan", "lavender"),
                color=c("gray80", "gray80"))
## lollipop plot
lolliplot(mutation.frequency,
          features, ranges=gr, type="circle",
          legend=legends)
```

## Example 11: plot methylation data from BED file with trackViewer {-#my-section}

Any type of data that can be imported into a `GRanges` object can be viewed by _trackViewer_ package.

Sample methylations are random data generated for illustration and are saved in BED format file. The _rtracklayer_ package is used to import the methylation data into a `GRanges`. The transcripts are extracted from `TxDb` object and are assigned gene symbol with `org` database. We also demonstrate that multiple transcripts can be shown in different colors and tracks.

```{r plotMethyBed, fig.width=12, fig.height=4, dpi=72, fig.cap="lollipop plot, pie layout"}
library(TxDb.Hsapiens.UCSC.hg19.knownGene) ## load package for gene model
library(org.Hs.eg.db) ## load package for gene name
library(rtracklayer)
## set the track range
gr <- GRanges("chr22", IRanges(50968014, 50970514, names="TYMP"))
## extract transcripts in the range
trs <- geneModelFromTxdb(TxDb.Hsapiens.UCSC.hg19.knownGene,
                         org.Hs.eg.db, gr=gr)
## subset the features to show the interested transcripts only
features <- GRangesList(trs[[1]]$dat, trs[[5]]$dat, trs[[6]]$dat)
flen <- elementNROWS(features)
features <- unlist(features)
## define the feature track layers
features$featureLayerID <- rep(1:2, c(sum(flen[-3]), flen[3]))
## define the feature labels
names(features) <- features$symbol
## define the feature colors
features$fill <- rep(c("lightblue", "mistyrose", "mistyrose"), flen)
## define the feature heights
features$height <- ifelse(features$feature=="CDS", .04, .02)
## import methylation data from a bed file
methy <- import(system.file("extdata", "methy.bed", package="trackViewer"), "BED")
## subset the data to simplify information
methy <- methy[methy$score > 20]
## for pie plot, there are must be at least two numeric columns
methy$score2 <- max(methy$score) - methy$score
## set the legends
legends <- list(labels=c("methylated", "unmethylated"),
                fill=c("white", "lightblue"),
                color=c("black", "black"))
## lollipop plot, pie layout
lolliplot(methy, features,
          ranges=gr, type="pie",
          legend=legends)
```

## Example 12: plot lollipop plot for multiple patients in "pie.stack" layout with trackViewer {-#my-section}

The percentage of methylation rates are shown by pie graph in different layers
for different patients.

```{r "plotMethypieStack", fig.width=12, fig.height=4, dpi=72, fig.cap="lollipop plot, pie.stack layout"}
## simulate multiple patients
rand.id <- sample.int(length(methy), 3*length(methy), replace=TRUE)
rand.id <- sort(rand.id)
methy.mul.patient <- methy[rand.id]
## pie.stack require metadata "stack.factor", and the metadata can not be stack.factor.order or stack.factor.first
len.max <- max(table(rand.id))
stack.factors <- paste0("patient",
                        formatC(1:len.max,
                                width=nchar(as.character(len.max)),
                                flag="0"))
methy.mul.patient$stack.factor <-
    unlist(lapply(table(rand.id), sample, x=stack.factors))
methy.mul.patient$score <-
    sample.int(100, length(methy.mul.patient), replace=TRUE)
## for a pie plot, two or more numeric meta-columns are required.
methy.mul.patient$score2 <- 100 - methy.mul.patient$score
## set different color set for different patient
patient.color.set <- as.list(as.data.frame(rbind(rainbow(length(stack.factors)),
                                                 "#FFFFFFFF"),
                                           stringsAsFactors=FALSE))
names(patient.color.set) <- stack.factors
methy.mul.patient$color <-
    patient.color.set[methy.mul.patient$stack.factor]
## set the legends
legends <- list(labels=stack.factors, col="gray80",
                fill=sapply(patient.color.set, `[`, 1))
## lollipop plot
lolliplot(methy.mul.patient,
          features, ranges=gr,
          type="pie.stack",
          legend=legends)
```

## Example 13: plot lollipop plot in caterpillar layout to compare two samples with trackViewer {-#my-section}

The caterpillar layout can be used to compare two samples or to display dense data side by side.

```{r plotCaterpillar, fig.width=12, fig.height=6, dpi=72, fig.cap="lollipop plot, caterpillar layout"}
## use SNPsideID to set the layer of event
sample.gr$SNPsideID <- sample(c("top", "bottom"),
                               length(sample.gr),
                               replace=TRUE)
lolliplot(sample.gr, features.gr)
```

## Example 14: dandelion plot hundreds SNPs with trackViewer {-#my-section}

Sometimes, there are as many as hundreds of SNPs or methylation status involved in one gene.
Dandelion plot can be used to depict such dense SNPs or methylation.
Please note that the height of the dandelion indicates the density of the events.

```{r dandelionPlot, fig.width=8, fig.height=4, dpi=72, fig.cap="dandelion plot"}
methy <- import(system.file("extdata", "methy.bed", package="trackViewer"), "BED")
length(methy)
## set the color of dandelion leaves.
methy$color <- 3
methy$border <- "gray"
## we suppose the total event are same (methy + unmethy)
## we rescale the methylation score by max value of the score
m <- max(methy$score)
methy$score <- methy$score/m
# The area of the fan indicate the percentage of methylation or rate of mutation.
dandelion.plot(methy, features, ranges=gr, type="fan")
```

# Session Infomation

```{r, echo=T,eval=T,message=F,warning=F,error=T}
sessionInfo()
```

---
*The lesson material was originally created by Harvard Chan Bioinformatics Core and UMass Medical School, and has been developed by members of the BMBL.*
